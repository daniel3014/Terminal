<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
<title>Terminal</title>

<style>
:root{
  --glass-light: rgba(255,255,255,0.55);
  --glass-dark: rgba(20,28,45,0.55);
  --border-light: rgba(255,255,255,0.35);
  --border-dark: rgba(255,255,255,0.15);

  --blur: blur(22px);
  --shadow: 0 25px 50px rgba(0,0,0,0.25);

  /* ‚úÖ Grid responsivo real (mobile ganha mais colunas automaticamente) */
  --grid-size: clamp(40px, 6.2vw, 60px);
  --grid-gap:  clamp(10px, 2.2vw, 18px);
  --shadow-inset: 12px;

  --cols: 12;
  --cell-w: 60px;

  /* ‚úÖ escala do painel (sem scroll) */
  --ui-scale: 1;

  /* padding do painel (tamb√©m responsivo) */
  --stage-pad-x: clamp(12px, 2.5vw, 16px);
  --stage-pad-y: clamp(14px, 2.8vw, 24px);
}

body[data-theme="light"]{
  background: linear-gradient(135deg, #e6f1ff, #cfe4ff);
  color: #0f172a;
  --grid-line: rgba(0,0,0,0.08);
}
body[data-theme="dark"]{
  background: linear-gradient(135deg, #020617, #0b1220);
  color: #e5e7eb;
  --grid-line: rgba(255,255,255,0.14);
}

*{ box-sizing:border-box; font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif; }

/* ‚úÖ Sem scroll + tela inteira */
html, body{
  height: 100%;
  overflow: hidden;
}

body{
  margin:0;
  padding: 0;
}

/* ‚úÖ Stage ocupa a tela inteira */
.stage{
  position: fixed;
  inset: 0;
  padding: var(--stage-pad-y) var(--stage-pad-x);
  overflow: hidden;
}

/* GRID OVERLAY TELA INTEIRA (EDIT MODE) */
body.edit-mode::before{
  content:"";
  position:fixed;
  inset:0;
  background-image:
    linear-gradient(to right, var(--grid-line) 1px, transparent 1px),
    linear-gradient(to bottom, var(--grid-line) 1px, transparent 1px);
  background-size:
    calc(var(--cell-w) + var(--grid-gap)) calc(var(--grid-size) + var(--grid-gap));
  pointer-events:none;
  z-index:0;
}

/* ‚úÖ GRID (painel) */
.app{
  position: relative;
  z-index: 1;

  display:grid;
  grid-template-columns: repeat(var(--cols), minmax(0, 1fr));
  grid-auto-rows: var(--grid-size);
  gap: var(--grid-gap);
  align-content:start;

  width: 100%;
  height: 100%;

  /* ‚úÖ Fit-to-screen quando fora do edit-mode */
  transform-origin: top left;
  transform: scale(var(--ui-scale));
  will-change: transform;
}

/* ‚úÖ Em edit-mode n√£o escala (drag fica perfeito) */
body.edit-mode .app{
  transform: none;
}

/* WRAP */
.widget-wrap{
  position:relative;

  --col: 1;
  --row: 1;
  --w: 4;
  --h: 2;

  --base-w: 4;
  --base-h: 2;

  grid-column: var(--col) / span var(--w);
  grid-row: var(--row) / span var(--h);

  touch-action:none;
  user-select:none;
}

/* SHADOW */
.widget-shadow{
  position:absolute;
  inset: var(--shadow-inset);
  border-radius: calc(26px - var(--shadow-inset));
  box-shadow: var(--shadow);
  pointer-events:none;
  z-index: 1;
}

/* WIDGET */
.widget-wrap > .widget{
  height: 100%;
  width: 100%;

  background: var(--glass-light);
  backdrop-filter: var(--blur);
  border: 1px solid var(--border-light);
  border-radius: 26px;
  padding: 22px;

  position:relative;
  z-index:2;

  box-shadow:none;
  touch-action:none;
  user-select:none;
}

body[data-theme="dark"] .widget-wrap > .widget{
  background: var(--glass-dark);
  border-color: var(--border-dark);
}

/* EDIT MODE */
.edit-mode .widget-wrap > .widget{ cursor:grab; }
.edit-mode .widget-wrap > .widget,
.edit-mode .widget-shadow{ animation: wiggle 0.35s ease-in-out infinite alternate; }

@keyframes wiggle{
  from { transform: rotate(-0.4deg); }
  to   { transform: rotate(0.4deg); }
}

.widget-wrap.dragging > .widget,
.widget-wrap.dragging > .widget-shadow{
  animation:none;
}

.widget-wrap.dragging{
  z-index: 50;
}

.widget-wrap.dragging.fixed{
  position: fixed !important;
  margin: 0 !important;
  pointer-events: none;
}

/* WIDGETS */
.widget.clock{ text-align:center; }
.clock-time{ font-size:64px; }
.clock-date{ opacity:0.6; }
.widget.forecast{ display:flex; justify-content:space-between; }

/* SLIDER */
#slider{
  position: fixed;
  top: 20px;
  right: 20px;
  width: 170px;
  height: 44px;
  z-index: 80;

  --tx: 0px;
  --ty: 0px;
  transform: translate(var(--tx), var(--ty));
  transition: transform 0.06s linear;

  touch-action:none;
  user-select:none;
}

#slider .slider-shadow{
  position:absolute;
  inset: var(--shadow-inset);
  border-radius: calc(999px - var(--shadow-inset));
  box-shadow: var(--shadow);
  pointer-events:none;
  z-index: 0;
}

#slider .theme-slider-ui{
  position:absolute;
  inset:0;
  border-radius:999px;

  background: var(--glass-light);
  backdrop-filter: var(--blur);
  border: 1px solid var(--border-light);

  display:grid;
  grid-template-columns: repeat(3, 1fr);
  cursor:pointer;

  z-index: 2;
}

body[data-theme="dark"] #slider .theme-slider-ui{
  background: var(--glass-dark);
  border-color: var(--border-dark);
}

#slider span{
  display:block;
  height:44px;
  line-height:44px;
  text-align:center;
  font-size:14px;
  z-index:2;
}

.slider-thumb{
  position:absolute;
  height:36px;
  width:54px;
  border-radius:999px;
  left:6px;
  top:4px;
  background: rgba(255,255,255,0.65);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(255,255,255,0.4);
  transition: left 0.25s ease;
  z-index:1;
}

body[data-theme="dark"] .slider-thumb{
  background: rgba(255,255,255,0.15);
  border-color: rgba(255,255,255,0.25);
}

/* EDIT TOGGLE */
.edit-toggle{
  position: fixed;
  right: 20px;
  bottom: 20px;
  height: 44px;
  padding: 0 14px;
  border-radius: 999px;

  background: var(--glass-light);
  backdrop-filter: var(--blur);
  border: 1px solid var(--border-light);

  display: inline-flex;
  align-items: center;
  gap: 10px;

  cursor: pointer;
  user-select: none;

  z-index: 90;
  box-shadow: var(--shadow);
}

body[data-theme="dark"] .edit-toggle{
  background: var(--glass-dark);
  border-color: var(--border-dark);
}

.edit-toggle .dot{
  width: 10px;
  height: 10px;
  border-radius: 999px;
  background: rgba(15, 23, 42, 0.35);
}

body[data-theme="dark"] .edit-toggle .dot{
  background: rgba(255,255,255,0.22);
}

body.edit-mode .edit-toggle .dot{
  background: rgba(34, 197, 94, 0.7);
}
</style>
</head>

<body data-theme="light">

<div id="slider" data-widget-id="slider">
  <div class="slider-shadow" aria-hidden="true"></div>
  <div class="theme-slider-ui" id="sliderUI">
    <div class="slider-thumb" id="thumb"></div>
    <span data-mode="light">‚òÄÔ∏è</span>
    <span data-mode="auto">AUTO</span>
    <span data-mode="dark">üåô</span>
  </div>
</div>

<div class="edit-toggle" id="editToggle" role="button" tabindex="0" aria-label="Alternar modo de edi√ß√£o">
  <div class="dot" aria-hidden="true"></div>
  <div id="editToggleText">Editar</div>
</div>

<div class="stage">
  <div class="app" id="grid">

    <div class="widget weather" data-widget-id="w-weather" data-w="4" data-h="2">
      <strong>23¬∞C ‚òÄÔ∏è</strong><br>
      Sensa√ß√£o 25¬∞ ¬∑ Chuva 10%
    </div>

    <div class="widget clock" data-widget-id="w-clock" data-w="8" data-h="3">
      <div class="clock-time" id="time"></div>
      <div class="clock-date" id="date"></div>
    </div>

    <div class="widget forecast" data-widget-id="w-forecast" data-w="4" data-h="2">
      <span>‚òÄÔ∏è 24¬∞</span>
      <span>üåßÔ∏è 22¬∞</span>
      <span>‚õÖ 23¬∞</span>
    </div>

    <div class="widget" data-widget-id="w-assistant" data-w="4" data-h="2">
      <span id="assistantTitle"></span>
    </div>

  </div>
</div>

<script>
/* CLOCK */
function updateClock(){
  const now = new Date();
  time.textContent = now.toLocaleTimeString("pt-BR",{hour:"2-digit",minute:"2-digit"});
  date.textContent = now.toLocaleDateString("pt-BR",{weekday:"long",day:"numeric",month:"long"});
}
updateClock();
setInterval(updateClock,1000);

/* ASSISTANT NAME */
function getAssistantName(){
  const v = (localStorage.getItem("assistant_name") || "").trim();
  return v || "Jarvis";
}
function setAssistantName(name){
  const n = String(name ?? "").trim();
  if(!n) return false;
  localStorage.setItem("assistant_name", n);
  renderAssistantName();
  return true;
}
function renderAssistantName(){
  const el = document.getElementById("assistantTitle");
  if(!el) return;
  el.textContent = `Widget futuro do ${getAssistantName()}`;
}
renderAssistantName();

/* GRID HELPERS */
const gridEl = document.getElementById("grid");

function gridSize(){
  return parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--grid-size")) || 60;
}
function gridGap(){
  return parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--grid-gap")) || 18;
}

function computeCols(){
  const w = gridEl.clientWidth;
  const GRID = gridSize();
  const GAP = gridGap();

  const pitchMin = GRID + GAP;
  const cols = Math.max(1, Math.floor((w + GAP) / pitchMin));
  document.documentElement.style.setProperty("--cols", cols);

  const cellW = (w - (cols - 1) * GAP) / cols;
  document.documentElement.style.setProperty("--cell-w", cellW + "px");
  return { cols, cellW };
}

function pxToNum(v){ return Number(String(v).replace("px","").trim()) || 0; }

function allWidgetWraps(){
  return Array.from(document.querySelectorAll(".widget-wrap"))
    .filter(el => el.style.display !== "none");
}

function getGridPos(el){
  const cs = getComputedStyle(el);
  return {
    col: parseInt(cs.getPropertyValue("--col")) || 1,
    row: parseInt(cs.getPropertyValue("--row")) || 1,
    w:   parseInt(cs.getPropertyValue("--w")) || 4,
    h:   parseInt(cs.getPropertyValue("--h")) || 2,
    baseW: parseInt(cs.getPropertyValue("--base-w")) || 4,
    baseH: parseInt(cs.getPropertyValue("--base-h")) || 2
  };
}

function setGridPos(el, col, row){
  el.style.setProperty("--col", String(col));
  el.style.setProperty("--row", String(row));
}

function setBaseSize(el, w, h){
  el.style.setProperty("--base-w", String(w));
  el.style.setProperty("--base-h", String(h));
}

function setGridSize(el, w, h){
  el.style.setProperty("--w", String(w));
  el.style.setProperty("--h", String(h));
}

function buildOccupancy(exceptEl){
  const { cols } = computeCols();
  const occ = new Set();

  const mark = (c,r) => occ.add(c + ":" + r);
  const isMarked = (c,r) => occ.has(c + ":" + r);

  for(const el of allWidgetWraps()){
    if(el === exceptEl) continue;
    const {col,row,w,h} = getGridPos(el);
    for(let yy=0; yy<h; yy++){
      for(let xx=0; xx<w; xx++){
        const cc = col + xx;
        const rr = row + yy;
        if(cc >= 1 && cc <= cols && rr >= 1) mark(cc, rr);
      }
    }
  }
  return { cols, isMarked };
}

function fitsAt(occ, col, row, w, h){
  if(col < 1 || row < 1) return false;
  if(col + w - 1 > occ.cols) return false;
  for(let yy=0; yy<h; yy++){
    for(let xx=0; xx<w; xx++){
      if(occ.isMarked(col + xx, row + yy)) return false;
    }
  }
  return true;
}

function findNearestFreeCell(exceptEl, targetCol, targetRow, w, h){
  const occ = buildOccupancy(exceptEl);

  const maxCol = Math.max(1, occ.cols - w + 1);
  const clampCol = (c) => Math.max(1, Math.min(maxCol, c));
  const clampRow = (r) => Math.max(1, r);

  let tc = clampCol(targetCol);
  let tr = clampRow(targetRow);

  if(fitsAt(occ, tc, tr, w, h)) return { col: tc, row: tr };

  const maxRings = 24;
  for(let ring=1; ring<=maxRings; ring++){
    for(let dy=-ring; dy<=ring; dy++){
      for(let dx=-ring; dx<=ring; dx++){
        if(Math.abs(dx) !== ring && Math.abs(dy) !== ring) continue;
        const c = clampCol(tc + dx);
        const r = clampRow(tr + dy);
        if(fitsAt(occ, c, r, w, h)) return { col: c, row: r };
      }
    }
  }
  return { col: tc, row: tr };
}

function gridOrigin(){
  return gridEl.getBoundingClientRect();
}

function pitchX(){
  const GRID = gridSize();
  const GAP = gridGap();
  const cellW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell-w")) || GRID;
  return cellW + GAP;
}
function pitchY(){
  const GRID = gridSize();
  const GAP = gridGap();
  return GRID + GAP;
}

function anchorFromCenter(centerX, centerY, w, h){
  const r = gridOrigin();
  const rawCenterCol = ((centerX - r.left) / pitchX()) + 1;
  const rawCenterRow = ((centerY - r.top)  / pitchY()) + 1;

  const targetCol = Math.round( rawCenterCol - (w - 1) / 2 );
  const targetRow = Math.round( rawCenterRow - (h - 1) / 2 );

  return { col: targetCol, row: targetRow };
}

/* WRAP WIDGETS */
function ensureWrappedWidgets(){
  const widgets = Array.from(document.querySelectorAll("#grid > .widget"));
  widgets.forEach(w => {
    if(w.parentElement && w.parentElement.classList.contains("widget-wrap")) return;

    const wrap = document.createElement("div");
    wrap.className = "widget-wrap";

    const dw = parseInt(w.getAttribute("data-w")) || (w.classList.contains("clock") ? 8 : 4);
    const dh = parseInt(w.getAttribute("data-h")) || (w.classList.contains("clock") ? 3 : 2);

    setGridSize(wrap, dw, dh);
    setBaseSize(wrap, dw, dh);

    const id = w.getAttribute("data-widget-id");
    if(id){
      wrap.setAttribute("data-widget-id", id);
      w.removeAttribute("data-widget-id");
    }

    const shadow = document.createElement("div");
    shadow.className = "widget-shadow";
    shadow.setAttribute("aria-hidden","true");

    w.parentNode.insertBefore(wrap, w);
    wrap.appendChild(shadow);
    wrap.appendChild(w);
  });
}

/* LAYOUT SAVE/LOAD */
let activeProfile = (localStorage.getItem("layout_profile") || "default").trim() || "default";
function layoutKey(){ return "terminal_layout_v3_" + activeProfile; }

function saveLayout(){
  const data = { _meta: { profile: activeProfile } };

  for(const el of allWidgetWraps()){
    const id = el.getAttribute("data-widget-id");
    if(!id) continue;
    const {col,row,w,h,baseW,baseH} = getGridPos(el);
    data[id] = { col, row, w, h, baseW, baseH, hidden: false };
  }

  const slider = document.getElementById("slider");
  if(slider){
    const cs = getComputedStyle(slider);
    data["slider"] = {
      tx: pxToNum(cs.getPropertyValue("--tx")),
      ty: pxToNum(cs.getPropertyValue("--ty")),
      hidden: false
    };
  }

  localStorage.setItem(layoutKey(), JSON.stringify(data));
}

function loadLayout(){
  const raw = localStorage.getItem(layoutKey());
  if(!raw) return false;
  let data; try{ data = JSON.parse(raw); } catch { return false; }

  for(const el of allWidgetWraps()){
    const id = el.getAttribute("data-widget-id");
    if(!id || !data[id]) continue;
    const v = data[id];

    if(typeof v.baseW === "number" && typeof v.baseH === "number") setBaseSize(el, v.baseW, v.baseH);
    if(typeof v.w === "number" && typeof v.h === "number") setGridSize(el, v.w, v.h);
    if(typeof v.col === "number" && typeof v.row === "number") setGridPos(el, v.col, v.row);
    if(v.hidden) el.style.display = "none";
  }

  const slider = document.getElementById("slider");
  if(slider && data["slider"]){
    const v = data["slider"];
    if(typeof v.tx === "number") slider.style.setProperty("--tx", v.tx + "px");
    if(typeof v.ty === "number") slider.style.setProperty("--ty", v.ty + "px");
    if(v.hidden) slider.style.display = "none";
  }

  return true;
}

function packInitial(){
  const { cols } = computeCols();
  const wraps = allWidgetWraps();

  const occ = new Set();
  const mark = (c,r) => occ.add(c + ":" + r);
  const isMarked = (c,r) => occ.has(c + ":" + r);

  function canPlace(col,row,w,h){
    if(col + w - 1 > cols) return false;
    for(let yy=0; yy<h; yy++){
      for(let xx=0; xx<w; xx++){
        if(isMarked(col + xx, row + yy)) return false;
      }
    }
    return true;
  }

  function place(el, col, row, w, h){
    setGridPos(el, col, row);
    for(let yy=0; yy<h; yy++){
      for(let xx=0; xx<w; xx++){
        mark(col + xx, row + yy);
      }
    }
  }

  let curRow = 1;
  for(const el of wraps){
    const {w,h} = getGridPos(el);
    let placed = false;

    for(let r=curRow; r<200 && !placed; r++){
      for(let c=1; c<=cols; c++){
        if(canPlace(c, r, w, h)){
          place(el, c, r, w, h);
          placed = true;
          curRow = r;
          break;
        }
      }
    }

    if(!placed){
      place(el, 1, curRow, Math.min(w, cols), h);
    }
  }
}

function reflowForCols(oldCols, newCols){
  const wraps = allWidgetWraps();

  const desired = wraps.map(el => {
    const p = getGridPos(el);
    const ratio = (oldCols <= 1) ? 0 : (p.col - 1) / (oldCols - 1);
    const newCol = Math.floor(ratio * Math.max(0, newCols - 1)) + 1;
    return { el, row: p.row, col: newCol, w: p.w, h: p.h };
  });

  desired.sort((a,b) => (a.row - b.row) || (a.col - b.col));

  for(const it of desired){
    setGridPos(it.el, it.col, it.row);
  }

  for(const it of desired){
    const best = findNearestFreeCell(it.el, it.col, it.row, it.w, it.h);
    setGridPos(it.el, best.col, best.row);
  }

  saveLayout();
}

/* RESPONSIVE OS ENGINE */
let currentDensity = "normal";

function getDensity(cols, width){
  if(width < 520) return "ultra";
  if(cols <= 4) return "compact";
  if(cols <= 9) return "normal";
  return "expanded";
}

function densityScale(d){
  if(d === "ultra") return 0.55;
  if(d === "compact") return 0.75;
  if(d === "expanded") return 1.15;
  return 1.0;
}

function applyResponsiveSizes(cols){
  const density = getDensity(cols, window.innerWidth);
  const scale = densityScale(density);

  for(const el of allWidgetWraps()){
    const p = getGridPos(el);

    let nw = Math.max(1, Math.round(p.baseW * scale));
    let nh = Math.max(1, Math.round(p.baseH * scale));

    nw = Math.min(nw, cols);

    setGridSize(el, nw, nh);

    const best = findNearestFreeCell(el, p.col, p.row, nw, nh);
    setGridPos(el, best.col, best.row);
  }

  currentDensity = density;
}

function captureRects(){
  const m = new Map();
  for(const el of allWidgetWraps()){
    m.set(el, el.getBoundingClientRect());
  }
  return m;
}

function animateFLIP(beforeMap){
  for(const el of allWidgetWraps()){
    const a = beforeMap.get(el);
    if(!a) continue;
    const b = el.getBoundingClientRect();
    const dx = a.left - b.left;
    const dy = a.top - b.top;
    if(!dx && !dy) continue;

    el.style.transition = "none";
    el.style.transform = `translate(${dx}px, ${dy}px)`;
    void el.offsetWidth;
    el.style.transition = "transform 260ms cubic-bezier(.2,.9,.2,1)";
    el.style.transform = "";
  }
}

/* ‚úÖ FIT-TO-SCREEN (sem scroll, estilo painel) */
function computeGridExtents(){
  const wraps = allWidgetWraps();
  let maxCol = 1;
  let maxRow = 1;
  for(const el of wraps){
    const p = getGridPos(el);
    maxCol = Math.max(maxCol, p.col + p.w - 1);
    maxRow = Math.max(maxRow, p.row + p.h - 1);
  }
  return { maxCol, maxRow };
}

function applyFitToScreen(){
  // em edit-mode n√£o escala (drag perfeito)
  if(document.body.classList.contains("edit-mode")){
    document.documentElement.style.setProperty("--ui-scale", "1");
    return;
  }

  const stage = document.querySelector(".stage");
  const r = stage.getBoundingClientRect();

  const GRID = gridSize();
  const GAP = gridGap();
  const cellW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell-w")) || GRID;

  const { maxCol, maxRow } = computeGridExtents();

  const contentW = (maxCol * cellW) + ((maxCol - 1) * GAP);
  const contentH = (maxRow * GRID) + ((maxRow - 1) * GAP);

  const availW = r.width;
  const availH = r.height;

  const s = Math.min(1, availW / Math.max(1, contentW), availH / Math.max(1, contentH));
  document.documentElement.style.setProperty("--ui-scale", String(s));
}

/* EDIT MODE */
let editTimer;
let suppressBodyClickUntil = 0;

function enableEdit(){
  document.body.classList.add("edit-mode");
  editToggleText.textContent = "Concluir";
  applyFitToScreen();
}
function disableEdit(){
  document.body.classList.remove("edit-mode");
  editToggleText.textContent = "Editar";
  applyFitToScreen();
}

function isWidgetArea(target){
  return !!(target.closest(".widget-wrap") || target.closest(".widget") || target.closest("#slider") || target.closest("#editToggle"));
}

gridEl.addEventListener("dblclick", e => {
  if(e.target.closest(".widget-wrap") || e.target.closest(".widget")) enableEdit();
});

gridEl.addEventListener("pointerdown", e => {
  if(!e.target.closest(".widget-wrap") && !e.target.closest(".widget")) return;
  editTimer = setTimeout(() => enableEdit(), 500);
});

gridEl.addEventListener("pointerup", () => clearTimeout(editTimer));
gridEl.addEventListener("pointerleave", () => clearTimeout(editTimer));

document.body.addEventListener("click", e => {
  if(Date.now() < suppressBodyClickUntil) return;
  if(!isWidgetArea(e.target)) disableEdit();
});

const editToggle = document.getElementById("editToggle");
const editToggleText = document.getElementById("editToggleText");

editToggle.addEventListener("click", e => {
  e.stopPropagation();
  if(document.body.classList.contains("edit-mode")) disableEdit();
  else enableEdit();
});

editToggle.addEventListener("keydown", e => {
  if(e.key === "Enter" || e.key === " "){
    e.preventDefault();
    if(document.body.classList.contains("edit-mode")) disableEdit();
    else enableEdit();
  }
});

/* WIDGET DRAG */
let dragged = null;
let dragPid = null;
let dragOffX = 0;
let dragOffY = 0;
let dragW = 0;
let dragH = 0;

function clearFixedStyles(el){
  el.style.left = "";
  el.style.top = "";
  el.style.width = "";
  el.style.height = "";
}

function setFixedRect(el, r){
  el.style.left = r.left + "px";
  el.style.top = r.top + "px";
  el.style.width = r.width + "px";
  el.style.height = r.height + "px";
}

function animateSettle(el, startRect, destRect){
  el.style.transition = "none";
  setFixedRect(el, startRect);
  void el.offsetWidth;

  el.style.transition = "left 160ms cubic-bezier(.2,.9,.2,1), top 160ms cubic-bezier(.2,.9,.2,1)";
  el.style.left = destRect.left + "px";
  el.style.top  = destRect.top + "px";

  const cleanup = () => {
    el.removeEventListener("transitionend", cleanup);
    el.style.transition = "";
    el.classList.remove("fixed");
    el.classList.remove("dragging");
    clearFixedStyles(el);
  };

  el.addEventListener("transitionend", cleanup);
  setTimeout(cleanup, 220);
}

function attachWidgetDrag(el){
  el.addEventListener("pointerdown", e => {
    if(!document.body.classList.contains("edit-mode")) return;
    const wrap = e.target.closest(".widget-wrap");
    if(!wrap || wrap !== el) return;

    dragged = wrap;
    dragged.classList.add("dragging");

    const rect = dragged.getBoundingClientRect();
    dragOffX = e.clientX - rect.left;
    dragOffY = e.clientY - rect.top;
    dragW = rect.width;
    dragH = rect.height;

    dragged.classList.add("fixed");
    setFixedRect(dragged, rect);

    dragPid = e.pointerId;
    dragged.setPointerCapture(dragPid);
  });

  el.addEventListener("pointermove", e => {
    if(!dragged || dragged !== el) return;

    const left = e.clientX - dragOffX;
    const top  = e.clientY - dragOffY;

    dragged.style.left = left + "px";
    dragged.style.top  = top + "px";
  });

  function endDrag(e, animate=true){
    if(!dragged) return;

    const startRect = dragged.getBoundingClientRect();
    const {w,h} = getGridPos(dragged);

    const centerX = (e.clientX - dragOffX) + dragW / 2;
    const centerY = (e.clientY - dragOffY) + dragH / 2;

    const target = anchorFromCenter(centerX, centerY, w, h);
    const best = findNearestFreeCell(dragged, target.col, target.row, w, h);
    setGridPos(dragged, best.col, best.row);

    dragged.classList.remove("fixed");
    clearFixedStyles(dragged);
    const destRect = dragged.getBoundingClientRect();

    dragged.classList.add("fixed");
    setFixedRect(dragged, startRect);
    void dragged.offsetWidth;

    try{ dragged.releasePointerCapture(dragPid); }catch(_){}
    dragPid = null;

    suppressBodyClickUntil = Date.now() + 250;
    saveLayout();

    if(animate){
      animateSettle(dragged, startRect, destRect);
    } else {
      dragged.classList.remove("fixed");
      dragged.classList.remove("dragging");
      clearFixedStyles(dragged);
    }

    dragged = null;

    // volta fit-to-screen fora do edit-mode
    applyFitToScreen();
  }

  el.addEventListener("pointerup", e => {
    if(!dragged || dragged !== el) return;
    endDrag(e, true);
  });

  el.addEventListener("pointercancel", e => {
    if(!dragged || dragged !== el) return;
    endDrag(e, false);
  });

  el.addEventListener("contextmenu", e => {
    if(!document.body.classList.contains("edit-mode")) return;
    e.preventDefault();

    const sizes = [
      {w:3,h:2},
      {w:4,h:2},
      {w:6,h:2},
      {w:8,h:3}
    ];

    const cur = getGridPos(el);
    let idx = sizes.findIndex(s => s.w === cur.baseW && s.h === cur.baseH);
    if(idx === -1) idx = sizes.findIndex(s => s.w === cur.w && s.h === cur.h);
    idx = (idx + 1) % sizes.length;
    const next = sizes[idx];

    setBaseSize(el, next.w, next.h);

    const before = captureRects();
    const newCols = computeCols().cols;
    applyResponsiveSizes(newCols);
    animateFLIP(before);

    suppressBodyClickUntil = Date.now() + 250;
    saveLayout();
    applyFitToScreen();
  });
}

/* SLIDER DRAG (FREE) */
const slider = document.getElementById("slider");
let sDragged=false, sPid=null, sStartX=0, sStartY=0, sBaseTX=0, sBaseTY=0;

function getSliderTXTY(){
  const cs = getComputedStyle(slider);
  return { tx: pxToNum(cs.getPropertyValue("--tx")), ty: pxToNum(cs.getPropertyValue("--ty")) };
}
function setSliderTXTY(tx,ty){
  slider.style.setProperty("--tx", tx + "px");
  slider.style.setProperty("--ty", ty + "px");
}

slider.addEventListener("pointerdown", e => {
  if(!document.body.classList.contains("edit-mode")) return;
  sDragged=true;
  sPid=e.pointerId;
  slider.setPointerCapture(sPid);
  sStartX=e.clientX; sStartY=e.clientY;
  const p = getSliderTXTY();
  sBaseTX=p.tx; sBaseTY=p.ty;
});
slider.addEventListener("pointermove", e => {
  if(!sDragged) return;
  const dx=e.clientX - sStartX;
  const dy=e.clientY - sStartY;
  setSliderTXTY(sBaseTX + dx, sBaseTY + dy);
});
slider.addEventListener("pointerup", e => {
  if(!sDragged) return;
  sDragged=false;
  try{ slider.releasePointerCapture(sPid); }catch(_){}
  sPid=null;
  suppressBodyClickUntil = Date.now() + 250;
  saveLayout();
});
slider.addEventListener("pointercancel", e => {
  if(!sDragged) return;
  sDragged=false;
  try{ slider.releasePointerCapture(sPid); }catch(_){}
  sPid=null;
  suppressBodyClickUntil = Date.now() + 250;
  saveLayout();
});

/* THEME SLIDER */
const sliderUI = document.getElementById("sliderUI");
const thumb = document.getElementById("thumb");
const modes = ["light","auto","dark"];
let currentMode = "auto";

function computeThumbLeft(mode){
  const idx = modes.indexOf(mode);
  const W = sliderUI.clientWidth;
  const seg = W / 3;
  const tw = thumb.offsetWidth;
  const center = seg * idx + seg/2;
  return (center - tw/2);
}
function setThumb(mode, animate=true){
  thumb.style.transition = animate ? "left 0.25s ease" : "none";
  thumb.style.left = computeThumbLeft(mode) + "px";
  currentMode = mode;
}

function applyTheme(mode){
  localStorage.setItem("theme_mode", mode);

  if(mode === "auto"){
    const h=new Date().getHours();
    document.body.dataset.theme = (h>=6 && h<18) ? "light" : "dark";
  } else {
    document.body.dataset.theme = mode;
  }

  setThumb(mode, true);
  saveLayout();
}

function modeFromX(x){
  const W = sliderUI.clientWidth;
  const third = W/3;
  if(x < third) return "light";
  if(x < third*2) return "auto";
  return "dark";
}

sliderUI.querySelectorAll("span").forEach(span => {
  span.addEventListener("click", e => {
    if(document.body.classList.contains("edit-mode")) return;
    e.stopPropagation();
    applyTheme(span.dataset.mode);
  });
});

let themeDrag=false, themePid=null;

sliderUI.addEventListener("pointerdown", e => {
  if(document.body.classList.contains("edit-mode")) return;
  themeDrag=true;
  themePid=e.pointerId;
  sliderUI.setPointerCapture(themePid);

  const r=sliderUI.getBoundingClientRect();
  const x=e.clientX-r.left;
  setThumb(modeFromX(x), false);
});
sliderUI.addEventListener("pointermove", e => {
  if(!themeDrag) return;
  const r=sliderUI.getBoundingClientRect();
  const x=Math.max(0, Math.min(r.width, e.clientX-r.left));
  setThumb(modeFromX(x), false);
});
sliderUI.addEventListener("pointerup", e => {
  if(!themeDrag) return;
  themeDrag=false;
  try{ sliderUI.releasePointerCapture(themePid); }catch(_){}
  themePid=null;

  const r=sliderUI.getBoundingClientRect();
  const x=Math.max(0, Math.min(r.width, e.clientX-r.left));
  applyTheme(modeFromX(x));
});
sliderUI.addEventListener("pointercancel", e => {
  if(!themeDrag) return;
  themeDrag=false;
  try{ sliderUI.releasePointerCapture(themePid); }catch(_){}
  themePid=null;
  applyTheme(currentMode);
});

/* ASSISTANT HOST API */
window.assistant = {
  setName(name){ return setAssistantName(name); },
  getName(){ return getAssistantName(); },

  setProfile(name){
    const n = String(name ?? "").trim();
    if(!n) return false;
    localStorage.setItem("layout_profile", n);
    activeProfile = n;
    const loaded = loadLayout();
    if(!loaded) packInitial();
    applyFitToScreen();
    return true;
  },
  getProfile(){
    return activeProfile;
  },

  removeWidget(id){
    const el = document.querySelector(`[data-widget-id="${id}"]`);
    if(!el) return false;
    el.style.display = "none";
    const raw = localStorage.getItem(layoutKey());
    const data = raw ? JSON.parse(raw) : {};
    data[id] = { ...(data[id]||{}), hidden: true };
    localStorage.setItem(layoutKey(), JSON.stringify(data));
    applyFitToScreen();
    return true;
  },
  showWidget(id){
    const el = document.querySelector(`[data-widget-id="${id}"]`);
    if(!el) return false;
    el.style.display = "";
    const raw = localStorage.getItem(layoutKey());
    const data = raw ? JSON.parse(raw) : {};
    if(data[id]) data[id].hidden = false;
    localStorage.setItem(layoutKey(), JSON.stringify(data));
    applyFitToScreen();
    return true;
  }
};

/* INIT */
ensureWrappedWidgets();
let lastCols = computeCols().cols;

const loaded = loadLayout();
if(!loaded) packInitial();

const savedMode = (localStorage.getItem("theme_mode") || "auto").trim();
applyTheme(modes.includes(savedMode) ? savedMode : "auto");

// aplica responsivo inicial
(function initialOSLayout(){
  const before = captureRects();
  const newCols = computeCols().cols;
  applyResponsiveSizes(newCols);
  reflowForCols(lastCols, newCols);
  animateFLIP(before);
  lastCols = newCols;
  applyFitToScreen();
})();

for(const w of allWidgetWraps()){
  attachWidgetDrag(w);
}

const ro = new ResizeObserver(() => {
  if(dragged || sDragged) return;

  const before = captureRects();
  const newCols = computeCols().cols;

  applyResponsiveSizes(newCols);

  if(newCols !== lastCols){
    reflowForCols(lastCols, newCols);
    lastCols = newCols;
  } else {
    for(const el of allWidgetWraps()){
      const p = getGridPos(el);
      const best = findNearestFreeCell(el, p.col, p.row, p.w, p.h);
      setGridPos(el, best.col, best.row);
    }
    saveLayout();
  }

  animateFLIP(before);
  applyFitToScreen();
});
ro.observe(gridEl);
</script>

</body>
</html>
