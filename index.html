<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Terminal</title>

<style>
:root{
  --glass-light: rgba(255,255,255,0.55);
  --glass-dark: rgba(20,28,45,0.55);
  --border-light: rgba(255,255,255,0.35);
  --border-dark: rgba(255,255,255,0.15);

  --blur: blur(22px);
  --shadow: 0 25px 50px rgba(0,0,0,0.25);

  --grid-size: 60px;
  --grid-gap: 18px;
  --snap-inset: 6px;
  --shadow-inset: 12px;

  --cols: 12;
}

/* THEMES */
body[data-theme="light"]{
  background: linear-gradient(135deg, #e6f1ff, #cfe4ff);
  color: #0f172a;
  --grid-line: rgba(0,0,0,0.08);
}
body[data-theme="dark"]{
  background: linear-gradient(135deg, #020617, #0b1220);
  color: #e5e7eb;
  --grid-line: rgba(255,255,255,0.14);
}

*{ box-sizing:border-box; font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif; }
body{ margin:0; min-height:100vh; padding:24px 16px; }

/* GRID OVERLAY (EDIT MODE) */
body.edit-mode::before{
  content:"";
  position:fixed;
  inset:0;
  background-image:
    linear-gradient(to right, var(--grid-line) 1px, transparent 1px),
    linear-gradient(to bottom, var(--grid-line) 1px, transparent 1px);
  background-size: calc(var(--grid-size) + var(--grid-gap)) calc(var(--grid-size) + var(--grid-gap));
  pointer-events:none;
  z-index:0;
}

/* GRID CONTAINER */
.app{
  max-width:1200px;
  margin:auto;
  position:relative;
  z-index:1;

  display:grid;
  grid-template-columns: repeat(var(--cols), var(--grid-size));
  grid-auto-rows: var(--grid-size);
  gap: var(--grid-gap);
  align-content:start;
}

/* GRID ITEM */
.widget-wrap{
  position:relative;

  --col: 1;
  --row: 1;
  --w: 4;
  --h: 2;

  grid-column: var(--col) / span var(--w);
  grid-row: var(--row) / span var(--h);

  touch-action:none;
  user-select:none;
}

.widget-shadow{
  position:absolute;
  inset: var(--shadow-inset);
  border-radius: calc(26px - var(--shadow-inset));
  box-shadow: var(--shadow);
  pointer-events:none;
  z-index: 1;
}

.widget-wrap > .widget{
  height: 100%;
  width: 100%;

  background: var(--glass-light);
  backdrop-filter: var(--blur);
  border: 1px solid var(--border-light);
  border-radius: 26px;
  padding: 22px;

  position:relative;
  z-index:2;

  box-shadow:none;
  touch-action:none;
  user-select:none;
}

body[data-theme="dark"] .widget-wrap > .widget{
  background: var(--glass-dark);
  border-color: var(--border-dark);
}

/* EDIT MODE */
.edit-mode .widget-wrap > .widget{ cursor:grab; }
.edit-mode .widget-wrap > .widget,
.edit-mode .widget-shadow{ animation: wiggle 0.35s ease-in-out infinite alternate; }

@keyframes wiggle{
  from { transform: rotate(-0.4deg); }
  to   { transform: rotate(0.4deg); }
}

.widget-wrap.dragging > .widget,
.widget-wrap.dragging > .widget-shadow{
  animation:none;
}

/* FIXED DRAG VISUAL */
.widget-wrap.dragging{
  z-index: 50;
}
.widget-wrap.dragging.fixed{
  position: fixed !important;
  margin: 0 !important;
  pointer-events: none;
}
.widget-wrap.placeholder{
  opacity: 0.0;
}

/* CLOCK / FORECAST */
.widget.clock{ text-align:center; }
.clock-time{ font-size:64px; }
.clock-date{ opacity:0.6; }
.widget.forecast{ display:flex; justify-content:space-between; }

/* THEME SLIDER */
#slider{
  position: fixed;
  top: 20px;
  right: 20px;
  width: 170px;
  height: 44px;
  z-index: 80;

  --tx: 0px;
  --ty: 0px;
  transform: translate(var(--tx), var(--ty));
  transition: transform 0.06s linear;

  touch-action:none;
  user-select:none;
}

#slider .slider-shadow{
  position:absolute;
  inset: var(--shadow-inset);
  border-radius: calc(999px - var(--shadow-inset));
  box-shadow: var(--shadow);
  pointer-events:none;
  z-index: 0;
}

#slider .theme-slider-ui{
  position:absolute;
  inset:0;
  border-radius:999px;

  background: var(--glass-light);
  backdrop-filter: var(--blur);
  border: 1px solid var(--border-light);

  display:grid;
  grid-template-columns: repeat(3, 1fr);
  cursor:pointer;

  z-index: 2;
}

body[data-theme="dark"] #slider .theme-slider-ui{
  background: var(--glass-dark);
  border-color: var(--border-dark);
}

#slider span{
  display:block;
  height:44px;
  line-height:44px;
  text-align:center;
  font-size:14px;
  z-index:2;
}

.slider-thumb{
  position:absolute;
  height:36px;
  width:54px;
  border-radius:999px;
  left:6px;
  top:4px;
  background: rgba(255,255,255,0.65);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(255,255,255,0.4);
  transition: left 0.25s ease;
  z-index:1;
}

body[data-theme="dark"] .slider-thumb{
  background: rgba(255,255,255,0.15);
  border-color: rgba(255,255,255,0.25);
}
</style>
</head>

<body data-theme="light">

<div id="slider" data-widget-id="slider">
  <div class="slider-shadow" aria-hidden="true"></div>
  <div class="theme-slider-ui" id="sliderUI">
    <div class="slider-thumb" id="thumb"></div>
    <span data-mode="light">‚òÄÔ∏è</span>
    <span data-mode="auto">AUTO</span>
    <span data-mode="dark">üåô</span>
  </div>
</div>

<div class="app" id="grid">

  <div class="widget weather" data-widget-id="w-weather">
    <strong>23¬∞C ‚òÄÔ∏è</strong><br>
    Sensa√ß√£o 25¬∞ ¬∑ Chuva 10%
  </div>

  <div class="widget clock" data-widget-id="w-clock">
    <div class="clock-time" id="time"></div>
    <div class="clock-date" id="date"></div>
  </div>

  <div class="widget forecast" data-widget-id="w-forecast">
    <span>‚òÄÔ∏è 24¬∞</span>
    <span>üåßÔ∏è 22¬∞</span>
    <span>‚õÖ 23¬∞</span>
  </div>

  <div class="widget" data-widget-id="w-assistant">
    <span id="assistantTitle"></span>
  </div>

</div>

<script>
/* CLOCK */
function updateClock(){
  const now = new Date();
  time.textContent = now.toLocaleTimeString("pt-BR",{hour:"2-digit",minute:"2-digit"});
  date.textContent = now.toLocaleDateString("pt-BR",{weekday:"long",day:"numeric",month:"long"});
}
updateClock();
setInterval(updateClock,1000);

/* ASSISTANT NAME */
function getAssistantName(){
  const v = (localStorage.getItem("assistant_name") || "").trim();
  return v || "Jarvis";
}
function setAssistantName(name){
  const n = String(name ?? "").trim();
  if(!n) return false;
  localStorage.setItem("assistant_name", n);
  renderAssistantName();
  return true;
}
function renderAssistantName(){
  const el = document.getElementById("assistantTitle");
  if(!el) return;
  el.textContent = `Widget futuro do ${getAssistantName()}`;
}
renderAssistantName();

/* GRID HELPERS */
const gridEl = document.getElementById("grid");
const GRID = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--grid-size")) || 60;
const GAP  = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--grid-gap")) || 18;

function pitch(){ return GRID + GAP; }

function computeCols(){
  const w = gridEl.clientWidth;
  const p = pitch();
  const cols = Math.max(1, Math.floor((w + GAP) / p));
  document.documentElement.style.setProperty("--cols", cols);
  return cols;
}

function pxToNum(v){ return Number(String(v).replace("px","").trim()) || 0; }

function ensureWrappedWidgets(){
  const widgets = Array.from(document.querySelectorAll("#grid > .widget"));
  widgets.forEach(w => {
    if(w.parentElement && w.parentElement.classList.contains("widget-wrap")) return;

    const wrap = document.createElement("div");
    wrap.className = "widget-wrap";
    wrap.style.setProperty("--w", String((w.classList.contains("clock")) ? 8 : 4));
    wrap.style.setProperty("--h", String((w.classList.contains("clock")) ? 3 : 2));

    const id = w.getAttribute("data-widget-id");
    if(id){
      wrap.setAttribute("data-widget-id", id);
      w.removeAttribute("data-widget-id");
    }

    const shadow = document.createElement("div");
    shadow.className = "widget-shadow";
    shadow.setAttribute("aria-hidden","true");

    w.parentNode.insertBefore(wrap, w);
    wrap.appendChild(shadow);
    wrap.appendChild(w);
  });
}

function allWidgetWraps(){
  return Array.from(document.querySelectorAll(".widget-wrap"))
    .filter(el => el.style.display !== "none");
}

function getGridPos(el){
  const cs = getComputedStyle(el);
  return {
    col: parseInt(cs.getPropertyValue("--col")) || 1,
    row: parseInt(cs.getPropertyValue("--row")) || 1,
    w:   parseInt(cs.getPropertyValue("--w")) || 4,
    h:   parseInt(cs.getPropertyValue("--h")) || 2
  };
}

function setGridPos(el, col, row){
  el.style.setProperty("--col", String(col));
  el.style.setProperty("--row", String(row));
}

function setGridSize(el, w, h){
  el.style.setProperty("--w", String(w));
  el.style.setProperty("--h", String(h));
}

function buildOccupancy(exceptEl){
  const cols = computeCols();
  const occ = new Set();

  function mark(col,row){ occ.add(col + ":" + row); }
  function isMarked(col,row){ return occ.has(col + ":" + row); }

  for(const el of allWidgetWraps()){
    if(el === exceptEl) continue;
    const {col,row,w,h} = getGridPos(el);
    for(let yy=0; yy<h; yy++){
      for(let xx=0; xx<w; xx++){
        const cc = col + xx;
        const rr = row + yy;
        if(cc >= 1 && cc <= cols && rr >= 1) mark(cc, rr);
      }
    }
  }

  return { cols, isMarked };
}

function fitsAt(occ, col, row, w, h){
  if(col < 1 || row < 1) return false;
  if(col + w - 1 > occ.cols) return false;

  for(let yy=0; yy<h; yy++){
    for(let xx=0; xx<w; xx++){
      if(occ.isMarked(col + xx, row + yy)) return false;
    }
  }
  return true;
}

function findNearestFreeCell(exceptEl, targetCol, targetRow, w, h){
  const occ = buildOccupancy(exceptEl);

  const clampCol = (c) => Math.max(1, Math.min(occ.cols - w + 1, c));
  const clampRow = (r) => Math.max(1, r);

  let tc = clampCol(targetCol);
  let tr = clampRow(targetRow);

  if(fitsAt(occ, tc, tr, w, h)) return {col: tc, row: tr};

  const maxRings = 24;
  for(let ring=1; ring<=maxRings; ring++){
    for(let dy=-ring; dy<=ring; dy++){
      for(let dx=-ring; dx<=ring; dx++){
        if(Math.abs(dx) !== ring && Math.abs(dy) !== ring) continue;
        const c = clampCol(tc + dx);
        const r = clampRow(tr + dy);
        if(fitsAt(occ, c, r, w, h)) return {col: c, row: r};
      }
    }
  }
  return {col: tc, row: tr};
}

/* LAYOUT SAVE/LOAD */
const LAYOUT_KEY = "terminal_layout_v3";

function saveLayout(){
  const data = {};
  for(const el of allWidgetWraps()){
    const id = el.getAttribute("data-widget-id");
    if(!id) continue;
    const {col,row,w,h} = getGridPos(el);
    data[id] = { col, row, w, h, hidden: false };
  }

  const slider = document.getElementById("slider");
  if(slider){
    const cs = getComputedStyle(slider);
    data["slider"] = {
      tx: pxToNum(cs.getPropertyValue("--tx")),
      ty: pxToNum(cs.getPropertyValue("--ty")),
      hidden: false
    };
  }

  localStorage.setItem(LAYOUT_KEY, JSON.stringify(data));
}

function loadLayout(){
  const raw = localStorage.getItem(LAYOUT_KEY);
  if(!raw) return false;
  let data; try{ data = JSON.parse(raw); } catch { return false; }

  for(const el of allWidgetWraps()){
    const id = el.getAttribute("data-widget-id");
    if(!id || !data[id]) continue;
    const v = data[id];
    if(typeof v.w === "number" && typeof v.h === "number") setGridSize(el, v.w, v.h);
    if(typeof v.col === "number" && typeof v.row === "number") setGridPos(el, v.col, v.row);
    if(v.hidden) el.style.display = "none";
  }

  const slider = document.getElementById("slider");
  if(slider && data["slider"]){
    const v = data["slider"];
    if(typeof v.tx === "number") slider.style.setProperty("--tx", v.tx + "px");
    if(typeof v.ty === "number") slider.style.setProperty("--ty", v.ty + "px");
    if(v.hidden) slider.style.display = "none";
  }

  return true;
}

function packInitial(){
  const cols = computeCols();
  const wraps = allWidgetWraps();

  const occ = new Set();
  const mark = (c,r) => occ.add(c + ":" + r);
  const isMarked = (c,r) => occ.has(c + ":" + r);

  function canPlace(col,row,w,h){
    if(col + w - 1 > cols) return false;
    for(let yy=0; yy<h; yy++){
      for(let xx=0; xx<w; xx++){
        if(isMarked(col + xx, row + yy)) return false;
      }
    }
    return true;
  }

  function place(el, col, row, w, h){
    setGridPos(el, col, row);
    for(let yy=0; yy<h; yy++){
      for(let xx=0; xx<w; xx++){
        mark(col + xx, row + yy);
      }
    }
  }

  let curRow = 1;
  for(const el of wraps){
    const {w,h} = getGridPos(el);
    let placed = false;

    for(let r=curRow; r<200 && !placed; r++){
      for(let c=1; c<=cols; c++){
        if(canPlace(c, r, w, h)){
          place(el, c, r, w, h);
          placed = true;
          curRow = r;
          break;
        }
      }
    }

    if(!placed){
      place(el, 1, curRow, Math.min(w, cols), h);
    }
  }
}

/* EDIT MODE */
let editTimer;
let suppressBodyClickUntil = 0;

function enableEdit(){ document.body.classList.add("edit-mode"); }
function disableEdit(){ document.body.classList.remove("edit-mode"); }

function isWidgetArea(target){
  return !!(target.closest(".widget-wrap") || target.closest(".widget") || target.closest("#slider"));
}

gridEl.addEventListener("dblclick", e => {
  if(e.target.closest(".widget-wrap") || e.target.closest(".widget")) enableEdit();
});

gridEl.addEventListener("pointerdown", e => {
  if(!e.target.closest(".widget-wrap") && !e.target.closest(".widget")) return;
  editTimer = setTimeout(enableEdit, 500);
});

gridEl.addEventListener("pointerup", () => clearTimeout(editTimer));
gridEl.addEventListener("pointerleave", () => clearTimeout(editTimer));

document.body.addEventListener("click", e => {
  if(Date.now() < suppressBodyClickUntil) return;
  if(!isWidgetArea(e.target)) disableEdit();
});

/* WIDGET DRAG (GRID) */
let dragged = null;
let placeholder = null;
let dragPid = null;
let dragOffX = 0;
let dragOffY = 0;

function pointToCell(clientX, clientY){
  const r = gridEl.getBoundingClientRect();
  const p = pitch();
  const x = clientX - r.left;
  const y = clientY - r.top;
  const col = Math.round(x / p) + 1;
  const row = Math.round(y / p) + 1;
  return { col, row };
}

function makePlaceholder(fromEl){
  const ph = document.createElement("div");
  ph.className = "widget-wrap placeholder";
  const {w,h,col,row} = getGridPos(fromEl);
  ph.style.setProperty("--w", String(w));
  ph.style.setProperty("--h", String(h));
  ph.style.setProperty("--col", String(col));
  ph.style.setProperty("--row", String(row));
  ph.innerHTML = `<div class="widget-shadow" aria-hidden="true"></div><div class="widget"></div>`;
  return ph;
}

function attachWidgetDrag(el){
  el.addEventListener("pointerdown", e => {
    if(!document.body.classList.contains("edit-mode")) return;
    const wrap = e.target.closest(".widget-wrap");
    if(!wrap || wrap !== el) return;

    dragged = wrap;
    dragged.classList.add("dragging");

    const rect = dragged.getBoundingClientRect();
    dragOffX = e.clientX - rect.left;
    dragOffY = e.clientY - rect.top;

    placeholder = makePlaceholder(dragged);
    dragged.parentNode.insertBefore(placeholder, dragged.nextSibling);

    dragged.classList.add("fixed");
    dragged.style.left = rect.left + "px";
    dragged.style.top = rect.top + "px";
    dragged.style.width = rect.width + "px";
    dragged.style.height = rect.height + "px";

    dragPid = e.pointerId;
    dragged.setPointerCapture(dragPid);
  });

  el.addEventListener("pointermove", e => {
    if(!dragged || dragged !== el) return;

    const left = e.clientX - dragOffX;
    const top  = e.clientY - dragOffY;
    dragged.style.left = left + "px";
    dragged.style.top  = top + "px";

    const {w,h} = getGridPos(dragged);
    const cell = pointToCell(e.clientX - dragOffX + (GRID/2), e.clientY - dragOffY + (GRID/2));
    const best = findNearestFreeCell(dragged, cell.col, cell.row, w, h);
    setGridPos(placeholder, best.col, best.row);
  });

  function endDrag(){
    if(!dragged) return;

    const {col,row} = getGridPos(placeholder);
    setGridPos(dragged, col, row);

    dragged.classList.remove("fixed");
    dragged.classList.remove("dragging");
    dragged.style.left = "";
    dragged.style.top = "";
    dragged.style.width = "";
    dragged.style.height = "";

    if(placeholder){
      placeholder.remove();
      placeholder = null;
    }

    try{ dragged.releasePointerCapture(dragPid); }catch(_){}
    dragged = null;
    dragPid = null;

    suppressBodyClickUntil = Date.now() + 250;
    saveLayout();
  }

  el.addEventListener("pointerup", e => {
    if(!dragged || dragged !== el) return;
    endDrag();
  });

  el.addEventListener("pointercancel", e => {
    if(!dragged || dragged !== el) return;
    endDrag();
  });
}

/* SLIDER DRAG (FREE) */
let sDragged=false, sPid=null, sStartX=0, sStartY=0, sBaseTX=0, sBaseTY=0;
function getSliderTXTY(){
  const cs = getComputedStyle(slider);
  return { tx: pxToNum(cs.getPropertyValue("--tx")), ty: pxToNum(cs.getPropertyValue("--ty")) };
}
function setSliderTXTY(tx,ty){
  slider.style.setProperty("--tx", tx + "px");
  slider.style.setProperty("--ty", ty + "px");
}

const slider = document.getElementById("slider");
slider.addEventListener("pointerdown", e => {
  if(!document.body.classList.contains("edit-mode")) return;
  sDragged=true;
  sPid=e.pointerId;
  slider.setPointerCapture(sPid);
  sStartX=e.clientX; sStartY=e.clientY;
  const p = getSliderTXTY();
  sBaseTX=p.tx; sBaseTY=p.ty;
});
slider.addEventListener("pointermove", e => {
  if(!sDragged) return;
  const dx=e.clientX - sStartX;
  const dy=e.clientY - sStartY;
  setSliderTXTY(sBaseTX + dx, sBaseTY + dy);
});
slider.addEventListener("pointerup", e => {
  if(!sDragged) return;
  sDragged=false;
  try{ slider.releasePointerCapture(sPid); }catch(_){}
  sPid=null;
  suppressBodyClickUntil = Date.now() + 250;
  saveLayout();
});
slider.addEventListener("pointercancel", e => {
  if(!sDragged) return;
  sDragged=false;
  try{ slider.releasePointerCapture(sPid); }catch(_){}
  sPid=null;
  suppressBodyClickUntil = Date.now() + 250;
  saveLayout();
});

/* THEME SLIDER */
const sliderUI = document.getElementById("sliderUI");
const thumb = document.getElementById("thumb");
const modes = ["light","auto","dark"];
let currentMode = "light";

function computeThumbLeft(mode){
  const idx = modes.indexOf(mode);
  const W = sliderUI.clientWidth;
  const seg = W / 3;
  const tw = thumb.offsetWidth;
  const center = seg * idx + seg/2;
  return (center - tw/2);
}
function setThumb(mode, animate=true){
  thumb.style.transition = animate ? "left 0.25s ease" : "none";
  thumb.style.left = computeThumbLeft(mode) + "px";
  currentMode = mode;
}
function applyTheme(mode){
  if(mode === "auto"){
    const h=new Date().getHours();
    document.body.dataset.theme = (h>=6 && h<18) ? "light" : "dark";
  } else {
    document.body.dataset.theme = mode;
  }
  setThumb(mode, true);
  saveLayout();
}
function modeFromX(x){
  const W = sliderUI.clientWidth;
  const third = W/3;
  if(x < third) return "light";
  if(x < third*2) return "auto";
  return "dark";
}

sliderUI.querySelectorAll("span").forEach(span => {
  span.addEventListener("click", e => {
    if(document.body.classList.contains("edit-mode")) return;
    e.stopPropagation();
    applyTheme(span.dataset.mode);
  });
});

let themeDrag=false, themePid=null;
sliderUI.addEventListener("pointerdown", e => {
  if(document.body.classList.contains("edit-mode")) return;
  themeDrag=true;
  themePid=e.pointerId;
  sliderUI.setPointerCapture(themePid);

  const r=sliderUI.getBoundingClientRect();
  const x=e.clientX-r.left;
  setThumb(modeFromX(x), false);
});
sliderUI.addEventListener("pointermove", e => {
  if(!themeDrag) return;
  const r=sliderUI.getBoundingClientRect();
  const x=Math.max(0, Math.min(r.width, e.clientX-r.left));
  setThumb(modeFromX(x), false);
});
sliderUI.addEventListener("pointerup", e => {
  if(!themeDrag) return;
  themeDrag=false;
  try{ sliderUI.releasePointerCapture(themePid); }catch(_){}
  themePid=null;

  const r=sliderUI.getBoundingClientRect();
  const x=Math.max(0, Math.min(r.width, e.clientX-r.left));
  applyTheme(modeFromX(x));
});
sliderUI.addEventListener("pointercancel", e => {
  if(!themeDrag) return;
  themeDrag=false;
  try{ sliderUI.releasePointerCapture(themePid); }catch(_){}
  themePid=null;
  applyTheme(currentMode);
});

/* ASSISTANT HOST API */
window.assistant = {
  setName(name){ return setAssistantName(name); },
  getName(){ return getAssistantName(); },
  removeWidget(id){
    const el = document.querySelector(`[data-widget-id="${id}"]`);
    if(!el) return false;
    el.style.display = "none";
    const raw = localStorage.getItem(LAYOUT_KEY);
    const data = raw ? JSON.parse(raw) : {};
    data[id] = { ...(data[id]||{}), hidden: true };
    localStorage.setItem(LAYOUT_KEY, JSON.stringify(data));
    return true;
  },
  showWidget(id){
    const el = document.querySelector(`[data-widget-id="${id}"]`);
    if(!el) return false;
    el.style.display = "";
    const raw = localStorage.getItem(LAYOUT_KEY);
    const data = raw ? JSON.parse(raw) : {};
    if(data[id]) data[id].hidden = false;
    localStorage.setItem(LAYOUT_KEY, JSON.stringify(data));
    return true;
  }
};

/* INIT */
ensureWrappedWidgets();
computeCols();

const ro = new ResizeObserver(() => {
  const prev = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--cols")) || 12;
  const now = computeCols();
  if(now !== prev){
    const loaded = loadLayout();
    if(!loaded) packInitial();
  }
});
ro.observe(gridEl);

const loaded = loadLayout();
if(!loaded) packInitial();

applyTheme("light");

for(const w of allWidgetWraps()){
  attachWidgetDrag(w);
}
</script>

</body>
</html>
