<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Terminal</title>

<style>
:root {
  --glass-light: rgba(255,255,255,0.55);
  --glass-dark: rgba(20,28,45,0.55);
  --border-light: rgba(255,255,255,0.35);
  --border-dark: rgba(255,255,255,0.15);

  --blur: blur(22px);
  --shadow: 0 25px 50px rgba(0,0,0,0.25);

  --grid-size: 60px;
  --snap-inset: 6px; /* ‚úÖ espa√ßo elegante dentro do ret√¢ngulo */
}

/* THEMES */
body[data-theme="light"] {
  background: linear-gradient(135deg, #e6f1ff, #cfe4ff);
  color: #0f172a;
  --grid-line: rgba(0,0,0,0.08);
}
body[data-theme="dark"] {
  background: linear-gradient(135deg, #020617, #0b1220);
  color: #e5e7eb;
  --grid-line: rgba(255,255,255,0.14);
}

* { box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
body { margin: 0; min-height: 100vh; padding: 24px 16px; }

/* GRID OVERLAY TELA INTEIRA (EDIT MODE) */
body.edit-mode::before{
  content:"";
  position:fixed;
  inset:0;
  background-image:
    linear-gradient(to right, var(--grid-line) 1px, transparent 1px),
    linear-gradient(to bottom, var(--grid-line) 1px, transparent 1px);
  background-size: var(--grid-size) var(--grid-size);
  pointer-events:none;
  z-index:0;
}

/* GRID CONTAINER */
.app{
  max-width:1200px;
  margin:auto;
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap:24px;
  position:relative;
  z-index:1;
}

/* ============================================================
   ‚úÖ FIX: SOMBRA EM LAYER SEPARADO (NUNCA SOBE SOBRE OUTROS)
   ============================================================ */
.widget-wrap{
  position: relative;
  touch-action: none;
  user-select: none;

  /* posi√ß√£o persistente */
  --tx: 0px;
  --ty: 0px;
}

/* sombra separada: fica sempre "atr√°s" dos widgets */
.widget-shadow{
  position:absolute;
  inset:0;
  border-radius: 26px;
  box-shadow: var(--shadow);
  pointer-events:none;

  /* importante: z-index baixo */
  z-index: 1;

  transform: translate(var(--tx), var(--ty));
  transition: transform 0.06s linear;
}

/* superf√≠cie do widget */
.widget-wrap > .widget{
  background: var(--glass-light);
  backdrop-filter: var(--blur);
  border: 1px solid var(--border-light);
  border-radius: 26px;
  padding: 22px;

  position: relative;
  z-index: 2;

  /* move s√≥ a superf√≠cie (e a sombra move junto via vari√°vel) */
  transform: translate(var(--tx), var(--ty));
  transition: transform 0.06s linear;

  box-shadow: none;
  touch-action: none;
  user-select: none;
}

body[data-theme="dark"] .widget-wrap > .widget{
  background: var(--glass-dark);
  border-color: var(--border-dark);
}

/* EDIT MODE */
.edit-mode .widget-wrap > .widget{
  cursor: grab;
}
.edit-mode .widget-wrap > .widget,
.edit-mode .widget-shadow{
  animation: wiggle 0.35s ease-in-out infinite alternate;
}
@keyframes wiggle{
  from { transform: translate(var(--tx), var(--ty)) rotate(-0.4deg); }
  to   { transform: translate(var(--tx), var(--ty)) rotate(0.4deg); }
}

/* durante drag: sobe s√≥ o conte√∫do, sombra continua abaixo */
.widget-wrap.dragging > .widget,
.widget-wrap.dragging > .widget-shadow{
  animation:none;
  transition:none;
}
.widget-wrap.dragging > .widget{
  cursor:grabbing;
  opacity:0.9;
  z-index: 30;  /* sobe s√≥ a superf√≠cie */
}

/* CLOCK (agora o grid-span precisa estar no WRAP) */
.widget-wrap.clock{ grid-column: span 2; }
.widget-wrap.clock > .widget{ text-align:center; }
.clock-time{ font-size:64px; }
.clock-date{ opacity:0.6; }

/* FORECAST (aplica s√≥ no widget, n√£o no wrap) */
.widget.forecast{ display:flex; justify-content:space-between; }

/* ============================================================
   THEME SLIDER (tamb√©m com sombra separada)
   ============================================================ */
#slider{
  position: fixed;
  top: 20px;
  right: 20px;
  width: 170px;
  height: 44px;
  z-index: 20;

  /* posi√ß√£o persistente */
  --tx: 0px;
  --ty: 0px;
}

/* sombra do slider fica atr√°s do app (n√£o cobre widgets) */
#slider .slider-shadow{
  position:absolute;
  inset:0;
  border-radius: 999px;
  box-shadow: var(--shadow);
  pointer-events:none;

  /* abaixo do app (app tem z-index:1) */
  z-index: 0;

  transform: translate(var(--tx), var(--ty));
  transition: transform 0.06s linear;
}

/* UI do slider fica por cima */
#slider .theme-slider-ui{
  position:absolute;
  inset:0;
  border-radius: 999px;

  background: var(--glass-light);
  backdrop-filter: var(--blur);
  border: 1px solid var(--border-light);

  display: grid;
  grid-template-columns: repeat(3, 1fr);
  cursor: pointer;

  z-index: 40; /* sempre acima dos widgets */

  transform: translate(var(--tx), var(--ty));
  transition: transform 0.06s linear;
}

body[data-theme="dark"] #slider .theme-slider-ui{
  background: var(--glass-dark);
  border-color: var(--border-dark);
}

#slider span{
  display:block;
  height:44px;
  line-height:44px;
  text-align:center;
  font-size:14px;
  z-index:2;
}

/* capsule thumb */
.slider-thumb{
  position:absolute;
  height:36px;
  width:54px;
  border-radius:999px;
  left:6px;
  top:4px;
  background: rgba(255,255,255,0.65);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(255,255,255,0.4);
  transition: left 0.25s ease;
  z-index:1;
}

body[data-theme="dark"] .slider-thumb{
  background: rgba(255,255,255,0.15);
  border-color: rgba(255,255,255,0.25);
}
</style>
</head>

<body data-theme="light">

<!-- THEME SLIDER (com sombra separada) -->
<div id="slider" data-widget-id="slider">
  <div class="slider-shadow" aria-hidden="true"></div>

  <div class="theme-slider-ui">
    <div class="slider-thumb" id="thumb"></div>
    <span data-mode="light">‚òÄÔ∏è</span>
    <span data-mode="auto">AUTO</span>
    <span data-mode="dark">üåô</span>
  </div>
</div>

<div class="app" id="grid">

  <div class="widget weather" data-widget-id="w-weather">
    <strong>23¬∞C ‚òÄÔ∏è</strong><br>
    Sensa√ß√£o 25¬∞ ¬∑ Chuva 10%
  </div>

  <div class="widget clock" data-widget-id="w-clock">
    <div class="clock-time" id="time"></div>
    <div class="clock-date" id="date"></div>
  </div>

  <div class="widget forecast" data-widget-id="w-forecast">
    <span>‚òÄÔ∏è 24¬∞</span>
    <span>üåßÔ∏è 22¬∞</span>
    <span>‚õÖ 23¬∞</span>
  </div>

  <div class="widget" data-widget-id="w-jarvis">
    Widget futuro do Jarvis
  </div>

</div>

<script>
/* CLOCK */
function updateClock() {
  const now = new Date();
  time.textContent = now.toLocaleTimeString("pt-BR",{hour:"2-digit",minute:"2-digit"});
  date.textContent = now.toLocaleDateString("pt-BR",{weekday:"long",day:"numeric",month:"long"});
}
updateClock();
setInterval(updateClock,1000);

/* HELPERS */
const GRID = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--grid-size")) || 60;
const INSET = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--snap-inset")) || 6;

function pxToNum(v){ return Number(String(v).replace("px","").trim()) || 0; }
function getTXTY(el){
  const cs = getComputedStyle(el);
  return { tx: pxToNum(cs.getPropertyValue("--tx")), ty: pxToNum(cs.getPropertyValue("--ty")) };
}
function setTXTY(el, tx, ty){ el.style.setProperty("--tx", tx + "px"); el.style.setProperty("--ty", ty + "px"); }

/* snap com inset elegante */
function snap(n){ return Math.round(n / GRID) * GRID + INSET; }

function rectShift(rect, dx, dy){
  return { left: rect.left+dx, top: rect.top+dy, right: rect.right+dx, bottom: rect.bottom+dy, width: rect.width, height: rect.height };
}
function intersects(a, b, pad=10){
  return !(a.right <= b.left + pad || a.left >= b.right - pad || a.bottom <= b.top + pad || a.top >= b.bottom - pad);
}

/* ============================================================
   ‚úÖ WRAP: cria .widget-wrap + .widget-shadow para cada widget
   (sem copiar classes que mudam layout interno, ex: forecast)
   ============================================================ */
(function wrapWidgetsForShadow(){
  const widgets = Array.from(document.querySelectorAll("#grid > .widget"));

  widgets.forEach(w => {
    if (w.parentElement && w.parentElement.classList.contains("widget-wrap")) return;

    const wrap = document.createElement("div");
    wrap.classList.add("widget-wrap");

    // mant√©m s√≥ classes necess√°rias para layout do grid (ex: clock span 2)
    if (w.classList.contains("clock")) wrap.classList.add("clock");

    // move data-widget-id pro wrap (evita duplicado)
    const id = w.getAttribute("data-widget-id");
    if (id) {
      wrap.setAttribute("data-widget-id", id);
      w.removeAttribute("data-widget-id");
    }

    const shadow = document.createElement("div");
    shadow.className = "widget-shadow";
    shadow.setAttribute("aria-hidden", "true");

    w.parentNode.insertBefore(wrap, w);
    wrap.appendChild(shadow);
    wrap.appendChild(w);
  });
})();

/* EDIT MODE */
let editTimer;
const gridEl = document.getElementById("grid");
function enableEdit(){ document.body.classList.add("edit-mode"); }
function disableEdit(){ document.body.classList.remove("edit-mode"); }

gridEl.addEventListener("dblclick", e => { if (e.target.closest(".widget")) enableEdit(); });
gridEl.addEventListener("pointerdown", e => { if (!e.target.closest(".widget")) return; editTimer = setTimeout(enableEdit, 500); });
gridEl.addEventListener("pointerup", () => clearTimeout(editTimer));
gridEl.addEventListener("pointerleave", () => clearTimeout(editTimer));
document.body.addEventListener("click", e => { if (!e.target.closest(".widget") && !e.target.closest("#slider")) disableEdit(); });

/* DRAGGABLES */
const draggableEls = () =>
  Array.from(document.querySelectorAll(".widget-wrap, #slider"))
    .filter(el => el.style.display !== "none");

/* helpers para colis√£o usando o ‚Äúvisual‚Äù (conte√∫do) */
function visualEl(el){
  return el.classList && el.classList.contains("widget-wrap")
    ? el.querySelector(".widget")
    : el;
}
function visualRect(el){
  return visualEl(el).getBoundingClientRect();
}

/* SAVE/LOAD */
function saveLayout(){
  const data = {};
  draggableEls().forEach(el => {
    const id = el.getAttribute("data-widget-id");
    if(!id) return;
    const {tx,ty} = getTXTY(el);
    data[id] = { tx, ty, hidden: false };
  });
  localStorage.setItem("terminal_layout_v2", JSON.stringify(data));
}
function loadLayout(){
  const raw = localStorage.getItem("terminal_layout_v2");
  if(!raw) return;
  let data; try{ data = JSON.parse(raw); } catch { return; }
  draggableEls().forEach(el => {
    const id = el.getAttribute("data-widget-id");
    if(!id || !data[id]) return;
    setTXTY(el, data[id].tx ?? 0, data[id].ty ?? 0);
    if(data[id].hidden) el.style.display="none";
  });
}

/* NO OVERLAP SEARCH */
function findNearestFreeSpot(el, targetTX, targetTY){
  const others = draggableEls().filter(x => x !== el);
  const curRect = visualRect(el);

  const {tx: curTX, ty: curTY} = getTXTY(el);
  const baseRect = rectShift(curRect, -curTX, -curTY); // sem transform

  const candidateRectAt = (tx,ty) => rectShift(baseRect, tx, ty);
  const occupied = () => others.map(o => visualRect(o));

  const isFree = (tx,ty) => {
    const r = candidateRectAt(tx,ty);
    for(const or of occupied()){
      if(intersects(r, or, 12)) return false;
    }
    return true;
  };

  if(isFree(targetTX, targetTY)) return {tx: targetTX, ty: targetTY};

  const maxRings = 18;
  for(let ring=1; ring<=maxRings; ring++){
    const step = GRID * ring;
    const tests = [
      {tx: targetTX + step, ty: targetTY},
      {tx: targetTX - step, ty: targetTY},
      {tx: targetTX, ty: targetTY + step},
      {tx: targetTX, ty: targetTY - step},
      {tx: targetTX + step, ty: targetTY + step},
      {tx: targetTX - step, ty: targetTY + step},
      {tx: targetTX + step, ty: targetTY - step},
      {tx: targetTX - step, ty: targetTY - step},
    ];
    for(const t of tests){
      const stx = snap(t.tx - INSET); // snap() j√° adiciona INSET; aqui evitamos acumular
      const sty = snap(t.ty - INSET);
      if(isFree(stx, sty)) return {tx: stx, ty: sty};
    }
  }
  return {tx: targetTX, ty: targetTY};
}

/* DRAG */
let dragged=null, startX=0, startY=0, baseTX=0, baseTY=0, pid=null;

function attachDrag(el){
  el.addEventListener("pointerdown", e => {
    if(el.id === "slider" && !document.body.classList.contains("edit-mode")) return;
    if(!document.body.classList.contains("edit-mode")) return;

    dragged = el;
    dragged.classList.add("dragging");
    startX = e.clientX; startY = e.clientY;
    const pos = getTXTY(dragged);
    baseTX = pos.tx; baseTY = pos.ty;
    pid = e.pointerId;
    dragged.setPointerCapture(pid);
  });

  el.addEventListener("pointermove", e => {
    if(!dragged || dragged !== el) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    setTXTY(dragged, baseTX + dx, baseTY + dy);
  });

  el.addEventListener("pointerup", e => {
    if(!dragged || dragged !== el) return;
    const {tx,ty} = getTXTY(dragged);
    const targetTX = snap(tx - INSET);
    const targetTY = snap(ty - INSET);
    const best = findNearestFreeSpot(dragged, targetTX, targetTY);
    setTXTY(dragged, best.tx, best.ty);

    dragged.classList.remove("dragging");
    try{ dragged.releasePointerCapture(pid); }catch(_){}
    dragged=null; pid=null;
    saveLayout();
  });

  el.addEventListener("pointercancel", e => {
    if(!dragged || dragged !== el) return;
    dragged.classList.remove("dragging");
    try{ dragged.releasePointerCapture(pid); }catch(_){}
    dragged=null; pid=null;
    saveLayout();
  });
}
draggableEls().forEach(attachDrag);
loadLayout();

/* THEME SLIDER: CLICK + DRAG-TO-SELECT */
const slider = document.getElementById("slider");
const thumb = document.getElementById("thumb");
const modes = ["light","auto","dark"];
let currentMode = "light";

function computeThumbLeft(mode){
  const idx = modes.indexOf(mode);
  const W = slider.clientWidth;
  const seg = W / 3;
  const tw = thumb.offsetWidth;
  const center = seg * idx + seg/2;
  return Math.round(center - tw/2);
}
function setThumb(mode, animate=true){
  thumb.style.transition = animate ? "left 0.25s ease" : "none";
  thumb.style.left = computeThumbLeft(mode) + "px";
  currentMode = mode;
}
function applyTheme(mode){
  if(mode === "auto"){
    const h=new Date().getHours();
    document.body.dataset.theme = (h>=6 && h<18) ? "light" : "dark";
  } else {
    document.body.dataset.theme = mode;
  }
  setThumb(mode, true);
  saveLayout();
}
function modeFromX(x){
  const W = slider.clientWidth;
  const third = W/3;
  if(x < third) return "light";
  if(x < third*2) return "auto";
  return "dark";
}

slider.querySelectorAll("span").forEach(span => {
  span.addEventListener("click", e => {
    if(document.body.classList.contains("edit-mode")) return;
    e.stopPropagation();
    applyTheme(span.dataset.mode);
  });
});

let themeDrag=false, themePid=null;

slider.addEventListener("pointerdown", e => {
  if(document.body.classList.contains("edit-mode")) return;
  themeDrag=true;
  themePid=e.pointerId;
  slider.setPointerCapture(themePid);

  const r=slider.getBoundingClientRect();
  const x=e.clientX-r.left;
  setThumb(modeFromX(x), false);
});

slider.addEventListener("pointermove", e => {
  if(!themeDrag) return;
  const r=slider.getBoundingClientRect();
  const x=Math.max(0, Math.min(r.width, e.clientX-r.left));
  setThumb(modeFromX(x), false);
});

slider.addEventListener("pointerup", e => {
  if(!themeDrag) return;
  themeDrag=false;
  try{ slider.releasePointerCapture(themePid); }catch(_){}
  themePid=null;

  const r=slider.getBoundingClientRect();
  const x=Math.max(0, Math.min(r.width, e.clientX-r.left));
  applyTheme(modeFromX(x));
});

slider.addEventListener("pointercancel", e => {
  if(!themeDrag) return;
  themeDrag=false;
  try{ slider.releasePointerCapture(themePid); }catch(_){}
  themePid=null;
  applyTheme(currentMode);
});

// init
applyTheme("light");

/* JARVIS HOOKS */
window.jarvis = {
  removeWidget(id){
    const el = document.querySelector(`[data-widget-id="${id}"]`) || document.getElementById(id);
    if(!el) return false;
    el.style.display = "none";
    const raw = localStorage.getItem("terminal_layout_v2");
    const data = raw ? JSON.parse(raw) : {};
    data[id] = { ...(data[id]||{}), hidden: true, tx: (data[id]?.tx ?? 0), ty: (data[id]?.ty ?? 0) };
    localStorage.setItem("terminal_layout_v2", JSON.stringify(data));
    return true;
  },
  showWidget(id){
    const el = document.querySelector(`[data-widget-id="${id}"]`) || document.getElementById(id);
    if(!el) return false;
    el.style.display = "";
    const raw = localStorage.getItem("terminal_layout_v2");
    const data = raw ? JSON.parse(raw) : {};
    if(data[id]) data[id].hidden = false;
    localStorage.setItem("terminal_layout_v2", JSON.stringify(data));
    return true;
  }
};
</script>

</body>
</html>
